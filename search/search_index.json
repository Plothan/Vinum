{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Vinum is a multi-paradigm library for powerful state management usage and is perfectly capable of running in performance-critical systems. Why Vinum? Vinum's implementation is ultra fast and is able to be used in the most performance-critical systems on Roblox. Vinum's API is declarative, therefore, you code in terms of end results rather than instructions. Self-containing and centralized state can be used independently of each other, but when you use them togther, it results in a readable and maintainable codebase. Vinum doesn't second guess you - In Vinum, you directly control the updates at the low level. This is because of Processors that Vinum asks from you every time you create an object - these functions return a boolean that will determine whether the update will pass or not.","title":"Home"},{"location":"#home","text":"Vinum is a multi-paradigm library for powerful state management usage and is perfectly capable of running in performance-critical systems.","title":"Home"},{"location":"#why-vinum","text":"Vinum's implementation is ultra fast and is able to be used in the most performance-critical systems on Roblox. Vinum's API is declarative, therefore, you code in terms of end results rather than instructions. Self-containing and centralized state can be used independently of each other, but when you use them togther, it results in a readable and maintainable codebase. Vinum doesn't second guess you - In Vinum, you directly control the updates at the low level. This is because of Processors that Vinum asks from you every time you create an object - these functions return a boolean that will determine whether the update will pass or not.","title":"Why Vinum?"},{"location":"API/","text":"API Reference This is the API Reference, which is the best place to get a quick refresh on objects' methods and such.","title":"API Center"},{"location":"API/#api-reference","text":"This is the API Reference, which is the best place to get a quick refresh on objects' methods and such.","title":"API Reference"},{"location":"API/Calc/","text":"Calc The object responsible for dynamic and derived values. function Calc < T > ( calculator : ( useState , useKeyState ) -> ( T ), updateProcessor : ( oldValue : T , newValue : T ) -> ( boolean ) ): Calc < T > Constructs and returns a calc object. Parameters calculator: (useState, useKeyState) -> (T) The function Calc calls to get the updated value once an update is occured in an dependency. updateProcessor: (oldValue: T, newValue: T) -> (boolean) The function Calc calls to determine whether to pass the current update or not. false will reject and true will accept. Object Methods get() function CalcObj : get () : T Returns the current stored value. Example Usage local DeathsGroup = Group ( Vinum . JustOk ) local kills = Hold ( 100 , Vinum . RefuseIfSimilar ) DeathsGroup : setKey ( \"myCurrentDeaths\" , 200 ) local kdRatio = Calc ( function ( useState , useKeyState ) return useState ( kills ) / useKeyState ( DeathsGroup , \"myCurrentDeaths\" ) end ) print ( kdRatio : get ()) -- 0.5","title":"Calc"},{"location":"API/Calc/#calc","text":"The object responsible for dynamic and derived values. function Calc < T > ( calculator : ( useState , useKeyState ) -> ( T ), updateProcessor : ( oldValue : T , newValue : T ) -> ( boolean ) ): Calc < T > Constructs and returns a calc object.","title":"Calc"},{"location":"API/Calc/#parameters","text":"calculator: (useState, useKeyState) -> (T) The function Calc calls to get the updated value once an update is occured in an dependency. updateProcessor: (oldValue: T, newValue: T) -> (boolean) The function Calc calls to determine whether to pass the current update or not. false will reject and true will accept.","title":"Parameters"},{"location":"API/Calc/#object-methods","text":"","title":"Object Methods"},{"location":"API/Calc/#get","text":"function CalcObj : get () : T Returns the current stored value.","title":"get()"},{"location":"API/Calc/#example-usage","text":"local DeathsGroup = Group ( Vinum . JustOk ) local kills = Hold ( 100 , Vinum . RefuseIfSimilar ) DeathsGroup : setKey ( \"myCurrentDeaths\" , 200 ) local kdRatio = Calc ( function ( useState , useKeyState ) return useState ( kills ) / useKeyState ( DeathsGroup , \"myCurrentDeaths\" ) end ) print ( kdRatio : get ()) -- 0.5","title":"Example Usage"},{"location":"API/Group/","text":"Group The object responsible for state centralization. function Group ( setProcessor : ( keyName : string , oldKeyValue : unknown , keyValue : unknown ) ): Group Constructs and returns a new Group object. Parameters setProcessor: (keyName: string, oldKeyValue: unknown, keyValue: unknown) -> (boolean) The function that Group uses to determine whether to pass updates or not. true will pass while false will dismiss. Object Methods setKey() function Group : setKey ( keyName : string , keyValue : any ) Stores keyValue in an internal storage with key as keyValue , and starts the dependency management if it hasn't already - additionally, updates all dependents if there are. Additionally, fires all connections that were connected by Group:onChange . getKey() function Group : getKey ( keyName : string ): any Returns the current saved value that is attached to the given keyName. asState() function Group : asState ( keyName : string ) Returns a table that emulates a self-containing state object. Useful for integration between centralized state and self-containing one. onChange() function Group : onChange ( fn : ( keyName : string , oldValue : unknown , keyValue : unknown ) -> () ) Connects a function to be fired when a key has been set()'ed - useful when you don't want to use group:asState and observes . Example Usage local LevelsGroup = Group ( Vinum . JustOk ) LevelsGroup : setKey ( 100 , \"Fighter\" ) print ( LevelsGroup : getKey ( 100 )) -- Fighter LevelsGroup : onChange ( function ( key , oldValue , newValue ) print ( key , oldValue , newValue ) end )","title":"Group"},{"location":"API/Group/#group","text":"The object responsible for state centralization. function Group ( setProcessor : ( keyName : string , oldKeyValue : unknown , keyValue : unknown ) ): Group Constructs and returns a new Group object.","title":"Group"},{"location":"API/Group/#parameters","text":"setProcessor: (keyName: string, oldKeyValue: unknown, keyValue: unknown) -> (boolean) The function that Group uses to determine whether to pass updates or not. true will pass while false will dismiss.","title":"Parameters"},{"location":"API/Group/#object-methods","text":"","title":"Object Methods"},{"location":"API/Group/#setkey","text":"function Group : setKey ( keyName : string , keyValue : any ) Stores keyValue in an internal storage with key as keyValue , and starts the dependency management if it hasn't already - additionally, updates all dependents if there are. Additionally, fires all connections that were connected by Group:onChange .","title":"setKey()"},{"location":"API/Group/#getkey","text":"function Group : getKey ( keyName : string ): any Returns the current saved value that is attached to the given keyName.","title":"getKey()"},{"location":"API/Group/#asstate","text":"function Group : asState ( keyName : string ) Returns a table that emulates a self-containing state object. Useful for integration between centralized state and self-containing one.","title":"asState()"},{"location":"API/Group/#onchange","text":"function Group : onChange ( fn : ( keyName : string , oldValue : unknown , keyValue : unknown ) -> () ) Connects a function to be fired when a key has been set()'ed - useful when you don't want to use group:asState and observes .","title":"onChange()"},{"location":"API/Group/#example-usage","text":"local LevelsGroup = Group ( Vinum . JustOk ) LevelsGroup : setKey ( 100 , \"Fighter\" ) print ( LevelsGroup : getKey ( 100 )) -- Fighter LevelsGroup : onChange ( function ( key , oldValue , newValue ) print ( key , oldValue , newValue ) end )","title":"Example Usage"},{"location":"API/Hold/","text":"Hold The object responsible for storing pure data. function Hold < T > ( ogValue : T , updateProcessor : ( oldValue : T , newValue : T ) -> ( boolean ) ): Hold < T > Constructs and returns a new Hold object. Parameters ogValue: T The value to be stored initially. updateProcessor: (oldValue: T, newValue: T) -> (boolean) The function Hold uses to determine whether to pass updates or not. true will pass while false will dismiss. Object Methods get() function Hold : get (): T Returns the current stored value. set() function Hold : set ( newValue : T ) Changes the current value to newValue , and then signal an update if updateProcessor returned true. Example Usage local health = Hold ( 100 , Vinum . JustOk ) print ( health : get ()) -- 100 health : set ( 20 ) print ( health : get ()) -- 20","title":"Hold"},{"location":"API/Hold/#hold","text":"The object responsible for storing pure data. function Hold < T > ( ogValue : T , updateProcessor : ( oldValue : T , newValue : T ) -> ( boolean ) ): Hold < T > Constructs and returns a new Hold object.","title":"Hold"},{"location":"API/Hold/#parameters","text":"ogValue: T The value to be stored initially. updateProcessor: (oldValue: T, newValue: T) -> (boolean) The function Hold uses to determine whether to pass updates or not. true will pass while false will dismiss.","title":"Parameters"},{"location":"API/Hold/#object-methods","text":"","title":"Object Methods"},{"location":"API/Hold/#get","text":"function Hold : get (): T Returns the current stored value.","title":"get()"},{"location":"API/Hold/#set","text":"function Hold : set ( newValue : T ) Changes the current value to newValue , and then signal an update if updateProcessor returned true.","title":"set()"},{"location":"API/Hold/#example-usage","text":"local health = Hold ( 100 , Vinum . JustOk ) print ( health : get ()) -- 100 health : set ( 20 ) print ( health : get ()) -- 20","title":"Example Usage"},{"location":"API/Match/","text":"Match The object responsible for performing multiple computation depending on an inputState 's value. function Match ( inputState : anyStateObject , cases : { [ any ]: ( useState , useKey ) -> ()}, updateProcessor : ( oldValue : any , newValue : any ) -> ( boolean ) ) Parameters inputState: anyStateObject The state object that we will match cases: { [any]: (useState, useKey) -> ()} A list of cases that Match will treat as multiple Calcs that can have their own dependencies. updateProcessor: (oldValue: any, newValue: any) -> (boolean) The function Match uses to determine whether to let updates pass or not. _____- Object Methods get() function Match : get (): any Returns the current value that is produced by the current case. Example Usage local root = Hold ( 23 , Vinum . JustOk ) local matcher = Match ( root , { [ 23 ] = function ( useState , useKeyState ) return \"hi\" end , [ \"default\" ] = function ( useState , useKeyState ) return \"notFound\" end , }) print ( matcher : get ()) -- hi","title":"Match"},{"location":"API/Match/#match","text":"The object responsible for performing multiple computation depending on an inputState 's value. function Match ( inputState : anyStateObject , cases : { [ any ]: ( useState , useKey ) -> ()}, updateProcessor : ( oldValue : any , newValue : any ) -> ( boolean ) )","title":"Match"},{"location":"API/Match/#parameters","text":"inputState: anyStateObject The state object that we will match cases: { [any]: (useState, useKey) -> ()} A list of cases that Match will treat as multiple Calcs that can have their own dependencies. updateProcessor: (oldValue: any, newValue: any) -> (boolean) The function Match uses to determine whether to let updates pass or not. _____-","title":"Parameters"},{"location":"API/Match/#object-methods","text":"","title":"Object Methods"},{"location":"API/Match/#get","text":"function Match : get (): any Returns the current value that is produced by the current case.","title":"get()"},{"location":"API/Match/#example-usage","text":"local root = Hold ( 23 , Vinum . JustOk ) local matcher = Match ( root , { [ 23 ] = function ( useState , useKeyState ) return \"hi\" end , [ \"default\" ] = function ( useState , useKeyState ) return \"notFound\" end , }) print ( matcher : get ()) -- hi","title":"Example Usage"},{"location":"API/Observe/","text":"Observe The object responsible for managing connections that run when a state object updates. function Observe ( state : anyStateObject , updateProcessor : ( newValue : any ) -> ( boolean ) ): Observe Constructs and returns a new Observe object. Parameters state: anyStateObject The state object we will listen to changes coming from updateProcessor: (newValue: any) -> (boolean) The function Observe uses to determine whether to fire its connections or not. Object Methods onChange() function Observe : onChange ( fn : ( newValue : any ) -> ()): disconnectorFunc Adds fn as a connection, and then return a function that removes the connection. Example Usage ```lua local health = Hold(100, Vinum.JustOk) local HealthObserver = Observe(health, Vinum.JustOk) HealthObserver:onChange(function(newValue) print(newValue) end) ```EWeS","title":"Observe"},{"location":"API/Observe/#observe","text":"The object responsible for managing connections that run when a state object updates. function Observe ( state : anyStateObject , updateProcessor : ( newValue : any ) -> ( boolean ) ): Observe Constructs and returns a new Observe object.","title":"Observe"},{"location":"API/Observe/#parameters","text":"state: anyStateObject The state object we will listen to changes coming from updateProcessor: (newValue: any) -> (boolean) The function Observe uses to determine whether to fire its connections or not.","title":"Parameters"},{"location":"API/Observe/#object-methods","text":"","title":"Object Methods"},{"location":"API/Observe/#onchange","text":"function Observe : onChange ( fn : ( newValue : any ) -> ()): disconnectorFunc Adds fn as a connection, and then return a function that removes the connection.","title":"onChange()"},{"location":"API/Observe/#example-usage","text":"```lua local health = Hold(100, Vinum.JustOk) local HealthObserver = Observe(health, Vinum.JustOk) HealthObserver:onChange(function(newValue) print(newValue) end) ```EWeS","title":"Example Usage"},{"location":"API/Processors/","text":"Processors A set of functions that are the \"standard\" default Processors. Functions Vinum.JustOk() function Vinum . JustOk (): true Returns true, therefore, accepts any and every update. Vinum.RefuseIfSimilar() function Vinum . RefuseIfSimilar ( oldValue : T , newValue : T ) : boolean Returns false if similar, and true if otherwise. Vinum.RefuseIfSimilarAndCleanup() function Vinum . RefuseIfSimilarAndCleanup ( oldValue : T , newValue : T ) : boolean Returns false if similar, and true if otherwise. Additionally, when true, it tries to cleanup the oldValue. Vinum.RefuseIfSimilarInGroup() function Vinum . RefuseIfSimilarInGroup ( keyName : string , oldValue : T , newValue : T ) : boolean Same as RefuseIfSimilar , but it is just a port to Groups . Vinum.RefuseIfSimilarAndCleanupInGroup() function Vinum . RefuseIfSimilarAndCleanupInGroup ( keyName : string , oldValue : T , newValue : T ) : boolean Same as RefuseIfSimilarAndCleanup , but it is just a port to Groups .","title":"Processors"},{"location":"API/Processors/#processors","text":"A set of functions that are the \"standard\" default Processors.","title":"Processors"},{"location":"API/Processors/#functions","text":"","title":"Functions"},{"location":"API/Processors/#vinumjustok","text":"function Vinum . JustOk (): true Returns true, therefore, accepts any and every update.","title":"Vinum.JustOk()"},{"location":"API/Processors/#vinumrefuseifsimilar","text":"function Vinum . RefuseIfSimilar ( oldValue : T , newValue : T ) : boolean Returns false if similar, and true if otherwise.","title":"Vinum.RefuseIfSimilar()"},{"location":"API/Processors/#vinumrefuseifsimilarandcleanup","text":"function Vinum . RefuseIfSimilarAndCleanup ( oldValue : T , newValue : T ) : boolean Returns false if similar, and true if otherwise. Additionally, when true, it tries to cleanup the oldValue.","title":"Vinum.RefuseIfSimilarAndCleanup()"},{"location":"API/Processors/#vinumrefuseifsimilaringroup","text":"function Vinum . RefuseIfSimilarInGroup ( keyName : string , oldValue : T , newValue : T ) : boolean Same as RefuseIfSimilar , but it is just a port to Groups .","title":"Vinum.RefuseIfSimilarInGroup()"},{"location":"API/Processors/#vinumrefuseifsimilarandcleanupingroup","text":"function Vinum . RefuseIfSimilarAndCleanupInGroup ( keyName : string , oldValue : T , newValue : T ) : boolean Same as RefuseIfSimilarAndCleanup , but it is just a port to Groups .","title":"Vinum.RefuseIfSimilarAndCleanupInGroup()"},{"location":"Tutorials/","text":"Get Started Hello there, welcome to the Vinum's tutorial section! In this section, you will be introduced to the tools that Vinum provides to let you build scalable and performant systems that require state management using Vinum. Vinum is in beta stage Vinum is still heavily in beta stage, which means you will probably encounter bugs, or major changes in behavior, or features being removed. Although don't let this stop you from ever using Vinum! Despite this, Vinum is still heavily-tested and is ready for public non-production use! Additionally, this is also the best place for you to suggest groundbreaking features without worrying about backwards compatibility. Needed Knowledge These tutorails assume that: You are comfortable with luau otherwise you will be learning Luau and Vinum at the same time, which is incredibly unproductive! You are comfortable with Roblox Studio, otherwise, you won't be able to build upon Vinum. Depending on your experience, some topics might be easy, or a little bit diffcult - take your time! How These Tutorials Work This section will explain some important notes about how tutorials will be presented in this Doc - please don't skip anything. \"Fundamental\" - The place for the basics that you at least need to start building applications using Vinum. \"Advanced\" - The place for advanced tutorials - You don't need those to build a normal application, although they are useful for scalable application development. The tutorials presented in both categories are arranged in an order to make it easier for you to learn concepts introduced by Vinum - you are advised to not skip any tutorial if you are a newcorner. It is perfectly fine to reread a tutorial if you want a quick refresh.","title":"Get Started"},{"location":"Tutorials/#get-started","text":"Hello there, welcome to the Vinum's tutorial section! In this section, you will be introduced to the tools that Vinum provides to let you build scalable and performant systems that require state management using Vinum. Vinum is in beta stage Vinum is still heavily in beta stage, which means you will probably encounter bugs, or major changes in behavior, or features being removed. Although don't let this stop you from ever using Vinum! Despite this, Vinum is still heavily-tested and is ready for public non-production use! Additionally, this is also the best place for you to suggest groundbreaking features without worrying about backwards compatibility.","title":"Get Started"},{"location":"Tutorials/#needed-knowledge","text":"These tutorails assume that: You are comfortable with luau otherwise you will be learning Luau and Vinum at the same time, which is incredibly unproductive! You are comfortable with Roblox Studio, otherwise, you won't be able to build upon Vinum. Depending on your experience, some topics might be easy, or a little bit diffcult - take your time!","title":"Needed Knowledge"},{"location":"Tutorials/#how-these-tutorials-work","text":"This section will explain some important notes about how tutorials will be presented in this Doc - please don't skip anything. \"Fundamental\" - The place for the basics that you at least need to start building applications using Vinum. \"Advanced\" - The place for advanced tutorials - You don't need those to build a normal application, although they are useful for scalable application development. The tutorials presented in both categories are arranged in an order to make it easier for you to learn concepts introduced by Vinum - you are advised to not skip any tutorial if you are a newcorner. It is perfectly fine to reread a tutorial if you want a quick refresh.","title":"How These Tutorials Work"},{"location":"Tutorials/advanced/group/","text":"Grouping State Sometimes, we don't want our state to be duplicated across multiple DataModel, and rather have it centralized in a single place for easy synced management. Vinum allows you to use this paradigm through its Group object. In order to use it, we first need to import its constructor: local Group = Vinum . Group And to create a group object, we first need to feed its constructor a set Processor that will act as the middleware: local LevelTags = Group ( function ( KeyName , oldKeyValue , KeyValue ) return true end ) About oldKeyValue Similar to both Match & Calc, if the key isn't already there, oldKeyValue will be {type = \"Symbol\", value \"None\"} , so account for that in your group-specific processors.` To set a key to a value in a group, use its LevelTags:setKey(keyName, keyValue) method. LevelTags : setKey ( 100 , \"Fighter\" ) LevelTags : setKey ( 300 , \"Protector\" ) To get a value using a key in LevelTags , we use its LevelTags:getKey(keyName) method: print ( LevelTags : getKey ( 100 )) -- Fighter Groups as well have a built-in utility for listening to changes that occur in a group: LevelTags : onChange ( function ( keyName , oldKeyValue , newKeyValue ) print ( keyName , oldKeyValue , newKeyValue ) end ) Additionally, Group s come packaged with a method that turns a key-value into a self-contained state object, that is group:asState(keyName) , which then can be used for powerful integration with other objects. local LEVEL_100_Tag = LevelTags : asState ( 100 ) Observe ( LEVEL_100_Tag , Vinum . JustOk ): onChange ( function () print ( \"yes\" ) end ) Additionally, to use groups in Calc's or Match's handler, we can use the provided useKeyState(keyName) : local exampleCalc = Calc ( function ( _ , useKeyState ) return useKeyState ( LevelTags , 100 ) end , Vinum . JustOk ) Why Centralization? State Centralization is a very respectable state management paradigm as it avoids state being duplicated in multiple DataModels. Unlike Rodux- which follows State centralization very strictly, Vinum rather gives you the tools to manage centralized state, but doesn't mostly care about how you approach it. Outside of this complex state management world, you have actually used state centralization in your games in a form of another - for example, using Roblox Attributes to centralize custom state about an object that is readable/writable by other pieces of code. State centralization also means that we have a single source of truth for something , not necessarily the whole Application's state, but rather a part of it. SSOT is important as it guarantees that we don't have multiple places that have duplicated state, such as a players health - additionally, it is better for memory-wise as well.","title":"Grouping State"},{"location":"Tutorials/advanced/group/#grouping-state","text":"Sometimes, we don't want our state to be duplicated across multiple DataModel, and rather have it centralized in a single place for easy synced management. Vinum allows you to use this paradigm through its Group object. In order to use it, we first need to import its constructor: local Group = Vinum . Group And to create a group object, we first need to feed its constructor a set Processor that will act as the middleware: local LevelTags = Group ( function ( KeyName , oldKeyValue , KeyValue ) return true end ) About oldKeyValue Similar to both Match & Calc, if the key isn't already there, oldKeyValue will be {type = \"Symbol\", value \"None\"} , so account for that in your group-specific processors.` To set a key to a value in a group, use its LevelTags:setKey(keyName, keyValue) method. LevelTags : setKey ( 100 , \"Fighter\" ) LevelTags : setKey ( 300 , \"Protector\" ) To get a value using a key in LevelTags , we use its LevelTags:getKey(keyName) method: print ( LevelTags : getKey ( 100 )) -- Fighter Groups as well have a built-in utility for listening to changes that occur in a group: LevelTags : onChange ( function ( keyName , oldKeyValue , newKeyValue ) print ( keyName , oldKeyValue , newKeyValue ) end ) Additionally, Group s come packaged with a method that turns a key-value into a self-contained state object, that is group:asState(keyName) , which then can be used for powerful integration with other objects. local LEVEL_100_Tag = LevelTags : asState ( 100 ) Observe ( LEVEL_100_Tag , Vinum . JustOk ): onChange ( function () print ( \"yes\" ) end ) Additionally, to use groups in Calc's or Match's handler, we can use the provided useKeyState(keyName) : local exampleCalc = Calc ( function ( _ , useKeyState ) return useKeyState ( LevelTags , 100 ) end , Vinum . JustOk )","title":"Grouping State"},{"location":"Tutorials/advanced/group/#why-centralization","text":"State Centralization is a very respectable state management paradigm as it avoids state being duplicated in multiple DataModels. Unlike Rodux- which follows State centralization very strictly, Vinum rather gives you the tools to manage centralized state, but doesn't mostly care about how you approach it. Outside of this complex state management world, you have actually used state centralization in your games in a form of another - for example, using Roblox Attributes to centralize custom state about an object that is readable/writable by other pieces of code. State centralization also means that we have a single source of truth for something , not necessarily the whole Application's state, but rather a part of it. SSOT is important as it guarantees that we don't have multiple places that have duplicated state, such as a players health - additionally, it is better for memory-wise as well.","title":"Why Centralization?"},{"location":"Tutorials/advanced/match/","text":"Matching State In this tutorial, you will be introduced to a new object that is Match . This object allows you to perform multiple computation depending on an InputState. We first need to import the constructor: local Match = Vinum . Match And to create a Match object, we need to feed a state object that is stateful (Check Processors for more info) , and a list of cases . Finally, an update processor: local level_100_tag = Hold ( \"Fighter\" , Vinum . JustOk ) local level = Hold ( 100 , Vinum . JustOk ) local tag = Match ( level , { [ 100 ] = function ( useState , useKeyState ) return useState ( level_100_tag ) end , [ \"default\" ] = function ( useState , useKeyState ) return \"NotFound\" end }, function ( oldValue , newValue ) return true end ) Processor Just like Calc, Match's creation uses the same pipeline when updating them, as such, your updateProcessor will get invoked during creation. This means you have to account for that. Vinum helps you by setting oldValue as {type = \"Symbol\", value = \"None} on creation. As you can see, We can perform computations similar to Calc , in fact, Match act as a multi-arm calc, where it manages \"multiple calcs\" at the same, and optimize them. To get a value from a Match, we use its ...:get() helper: print ( tag : get ()) -- Fighter If we changed level_100_tag state object to something else, our Match will recompute to match it. level_100_tag : set ( \"HelloNoob\" ) print ( tag : get ()) -- \"HellowNoob\" And if we changed the inputState value to something else, Match will recompute and choose a case that matches the new value, otherwise it will default to the \"default\" case: level : set ( 40 ) -- an unsupported case print ( tag : get ()) -- NotFound, which is provided by the \"default\" case. Note As an optimization, Match will not recompute due to changes performed by dependencies that aren't related to the current case. This works since once inputState changes its value, Match will do a recompute anyway, so there is no need to perform unneeded computations Why not a Calc? You may be wondering, why not use a Calc for this case? Consider the following example - The intent here is to exactly implement the same \"level tags\" system we created above. local level_100_tag = Hold ( \"Fighter\" , Vinum . JustOk ) local level = Hold ( 100 , Vinum . JustOk ) local tag = Calc ( function ( useState , useKeyState ) local currentLevel = useState ( level ) return ( currentLevel == 100 ) and useState ( level_100_tag ) or \"NotFound\" end , Vinum . JustOk ) print ( tag : get ()) -- Fighter This works, although there a few problems with this: If currentLevel isn't even equal to 100, any changes to level_100_tag will cause an unneeded computation, making no difference in its value. Our code will become very messy when we add more dependencies Not O(1) - This means that our code will be spend much more time searching for the right value to return/compute. Prone to human & logical bugs Using Match , it eliminated these problems: It will not recompute if a dependency that isn't related to the current case changes. Our code is understandable and easier to reason about at the first glance O(1)/O(2) - Our code is guaranteed to find our desired case in 1 or 2 steps. Chances of a logical bug is very slim, as it uses a specific mechanism that is heavily tested under many conditions.","title":"Matching State"},{"location":"Tutorials/advanced/match/#matching-state","text":"In this tutorial, you will be introduced to a new object that is Match . This object allows you to perform multiple computation depending on an InputState. We first need to import the constructor: local Match = Vinum . Match And to create a Match object, we need to feed a state object that is stateful (Check Processors for more info) , and a list of cases . Finally, an update processor: local level_100_tag = Hold ( \"Fighter\" , Vinum . JustOk ) local level = Hold ( 100 , Vinum . JustOk ) local tag = Match ( level , { [ 100 ] = function ( useState , useKeyState ) return useState ( level_100_tag ) end , [ \"default\" ] = function ( useState , useKeyState ) return \"NotFound\" end }, function ( oldValue , newValue ) return true end ) Processor Just like Calc, Match's creation uses the same pipeline when updating them, as such, your updateProcessor will get invoked during creation. This means you have to account for that. Vinum helps you by setting oldValue as {type = \"Symbol\", value = \"None} on creation. As you can see, We can perform computations similar to Calc , in fact, Match act as a multi-arm calc, where it manages \"multiple calcs\" at the same, and optimize them. To get a value from a Match, we use its ...:get() helper: print ( tag : get ()) -- Fighter If we changed level_100_tag state object to something else, our Match will recompute to match it. level_100_tag : set ( \"HelloNoob\" ) print ( tag : get ()) -- \"HellowNoob\" And if we changed the inputState value to something else, Match will recompute and choose a case that matches the new value, otherwise it will default to the \"default\" case: level : set ( 40 ) -- an unsupported case print ( tag : get ()) -- NotFound, which is provided by the \"default\" case. Note As an optimization, Match will not recompute due to changes performed by dependencies that aren't related to the current case. This works since once inputState changes its value, Match will do a recompute anyway, so there is no need to perform unneeded computations","title":"Matching State"},{"location":"Tutorials/advanced/match/#why-not-a-calc","text":"You may be wondering, why not use a Calc for this case? Consider the following example - The intent here is to exactly implement the same \"level tags\" system we created above. local level_100_tag = Hold ( \"Fighter\" , Vinum . JustOk ) local level = Hold ( 100 , Vinum . JustOk ) local tag = Calc ( function ( useState , useKeyState ) local currentLevel = useState ( level ) return ( currentLevel == 100 ) and useState ( level_100_tag ) or \"NotFound\" end , Vinum . JustOk ) print ( tag : get ()) -- Fighter This works, although there a few problems with this: If currentLevel isn't even equal to 100, any changes to level_100_tag will cause an unneeded computation, making no difference in its value. Our code will become very messy when we add more dependencies Not O(1) - This means that our code will be spend much more time searching for the right value to return/compute. Prone to human & logical bugs Using Match , it eliminated these problems: It will not recompute if a dependency that isn't related to the current case changes. Our code is understandable and easier to reason about at the first glance O(1)/O(2) - Our code is guaranteed to find our desired case in 1 or 2 steps. Chances of a logical bug is very slim, as it uses a specific mechanism that is heavily tested under many conditions.","title":"Why not a Calc?"},{"location":"Tutorials/fundamental/calc/","text":"Calculating State In this tutorial, you will be introduced to a new object that allows for efficient derived values, that is Calc ! We first need to import its constructor: local Calc = Vinum . Calc Now, to create a calc, we first need to feed two parameters into its constructor, one that is the calculator, and the other one is the Processor. local dynamicMidHealth = Calc ( function ( useState , useKeyState ) end , function ( oldValue , newValue ) return true end ) Processors and Calcs Internally, on creation, Calcs use the same pipeline as updating them, so your Processor should account for that. To make this easier for you, Vinum right before updating the Calc, attaches a value that is {type = \"Symbol\", value \"None\"} to it. At the moment, you don't have to worry about useKeyState , it is just another method for interaction with another object. On the other hand, useState is a helper function that is used for subscribing dependencies into the Calc. Using useState : local health = Hold ( 100 , Vinum . RefuseIfSimilar ) local midHealth = Calc ( function ( useState ) return useState ( health ) / 2 end , Vinum . JustOk ) Now to get the value, we use midHealth:get() : print ( midHealth : get ()) -- 50 When to use Calcs Calcs are a little bit more speicalized than Holds and Observes. They are designed to make it easy to derive new values from existing state objects. Derived values are very common in statefull systems, such as UIs. For example, if we have a death message that includes Killed By , then it needs the killer's name as a dependency. This is possible using Observe and Hold alone, although your code will get ultimately messy. Consider the following code that doesn't use Calc. The intent is to create a death message that is synced at all times. local Killer = Hold ( PlrObject , Vinum . JustOk ) local Message = Hold ( string.format ( \"I got killed by &s\" , Killer : get ()), Vinum . JustOk ) local killerObserver = Observe ( Killer , Vinum . JustOk ) killerObserver : onChange ( function ( newValue ) message : set ( string.format ( \"I got killed by &s\" , newValue )) end ) There are a few problems with this: It isn't clear at first what this code is doing, making it harder to reason about. This will get overly complicated once we start introducing more dependencies. Logic is repeated, when Message is created and in killerObserver 's connection. You manage the pipeline, which means desync bugs can slip in While with a Calc object: local Killer = Hold ( PlrObject , Vinum . JustOk ) local Message = Calc ( function ( useState ) return string.format ( \"I got killed by &s\" , useState ( Killer )) end , Vinum . JustOk ) This is clear and is easier to reason about. It is scalable - you can add as many dependencies as you want, and chances you will get a readable code are still high. Logic is all contained in Calc's callback Calc's manages its own pipeline, which means it is less prone to errors.","title":"Calculating State"},{"location":"Tutorials/fundamental/calc/#calculating-state","text":"In this tutorial, you will be introduced to a new object that allows for efficient derived values, that is Calc ! We first need to import its constructor: local Calc = Vinum . Calc Now, to create a calc, we first need to feed two parameters into its constructor, one that is the calculator, and the other one is the Processor. local dynamicMidHealth = Calc ( function ( useState , useKeyState ) end , function ( oldValue , newValue ) return true end ) Processors and Calcs Internally, on creation, Calcs use the same pipeline as updating them, so your Processor should account for that. To make this easier for you, Vinum right before updating the Calc, attaches a value that is {type = \"Symbol\", value \"None\"} to it. At the moment, you don't have to worry about useKeyState , it is just another method for interaction with another object. On the other hand, useState is a helper function that is used for subscribing dependencies into the Calc. Using useState : local health = Hold ( 100 , Vinum . RefuseIfSimilar ) local midHealth = Calc ( function ( useState ) return useState ( health ) / 2 end , Vinum . JustOk ) Now to get the value, we use midHealth:get() : print ( midHealth : get ()) -- 50","title":"Calculating State"},{"location":"Tutorials/fundamental/calc/#when-to-use-calcs","text":"Calcs are a little bit more speicalized than Holds and Observes. They are designed to make it easy to derive new values from existing state objects. Derived values are very common in statefull systems, such as UIs. For example, if we have a death message that includes Killed By , then it needs the killer's name as a dependency. This is possible using Observe and Hold alone, although your code will get ultimately messy. Consider the following code that doesn't use Calc. The intent is to create a death message that is synced at all times. local Killer = Hold ( PlrObject , Vinum . JustOk ) local Message = Hold ( string.format ( \"I got killed by &s\" , Killer : get ()), Vinum . JustOk ) local killerObserver = Observe ( Killer , Vinum . JustOk ) killerObserver : onChange ( function ( newValue ) message : set ( string.format ( \"I got killed by &s\" , newValue )) end ) There are a few problems with this: It isn't clear at first what this code is doing, making it harder to reason about. This will get overly complicated once we start introducing more dependencies. Logic is repeated, when Message is created and in killerObserver 's connection. You manage the pipeline, which means desync bugs can slip in While with a Calc object: local Killer = Hold ( PlrObject , Vinum . JustOk ) local Message = Calc ( function ( useState ) return string.format ( \"I got killed by &s\" , useState ( Killer )) end , Vinum . JustOk ) This is clear and is easier to reason about. It is scalable - you can add as many dependencies as you want, and chances you will get a readable code are still high. Logic is all contained in Calc's callback Calc's manages its own pipeline, which means it is less prone to errors.","title":"When to use Calcs"},{"location":"Tutorials/fundamental/hold/","text":"Holding State You might be scared from the name \"Holding State\", however, it is really simple! In Vinum, \"Holding State\" is just saving data into the object Hold ! But what are Hold s? They are objects that we can use to store data into, and then read from and write to. we first need to require Hold 's constructor (this assumes you already installed Vinum and placed it in ReplicatedStorage) local Hold = Vinum . Hold Now to create a Hold , we have to feed it an initial value (otherwise it would default ot `{type = \"Symbol\", value = \"None\"}) and a Processor that has to be a function that returns a boolean. local Health = Hold ( 100 , function ( oldValue , NewValue ) return true end ) Now, to read that value, we can use Health:get() : print ( Health : get ()) -- 100 Now to write to it, we can use Health:set(newValue) : Health : set ( 50 ) print ( Health : get ()) -- 50 By default, Vinum accepts changes that set the same value - this is because Vinum doesn't want to restrict you in any way with how you want to manage your projects to some extent, although you can use Vinum.RefuseIfSimilar Processor instead of the function you already passed to implement this. Why: The Problem Hold object doesn't seem to do much rather than simulating a normal variable, so why not use a variable directly? The problem here is that luau variables don't change when any of their dependencies (pieces of data/code we depend on) change. Take this for example: local Health = 100 local midHealth = Health / 2 print ( midHealth ) -- 50 Health = 50 print ( midHealth ) -- 50? In this example, midHealth was actually correct, however, when Health changed to 50, midHealth remained 50, rather than changing to 25. So, to cut a long story short, we don't really have a way to sync variables, and in order to solve that, we need objects that exactly do that for us. Why: The Fix The fix is to have simple objects that at least store a list of dependents (places that depend on us) , so we know who to notify when there is a change. Vinum implements this in the form of \"graph objects\", they are little objects that store a list of dependencies and dependents. They are the objects that are behind all Vinum magic, and in fact Hold is just an abstract object that lets you communicate with them. Hold on the other hand, is designed to act as \"safe-variable\" state object, it has an additional method that is set() that lets you change what value it is Hold ing - additionally, it uses the processor you gave it to determine whether to change its value and notify its dependents, or not.","title":"Holding State"},{"location":"Tutorials/fundamental/hold/#holding-state","text":"You might be scared from the name \"Holding State\", however, it is really simple! In Vinum, \"Holding State\" is just saving data into the object Hold ! But what are Hold s? They are objects that we can use to store data into, and then read from and write to. we first need to require Hold 's constructor (this assumes you already installed Vinum and placed it in ReplicatedStorage) local Hold = Vinum . Hold Now to create a Hold , we have to feed it an initial value (otherwise it would default ot `{type = \"Symbol\", value = \"None\"}) and a Processor that has to be a function that returns a boolean. local Health = Hold ( 100 , function ( oldValue , NewValue ) return true end ) Now, to read that value, we can use Health:get() : print ( Health : get ()) -- 100 Now to write to it, we can use Health:set(newValue) : Health : set ( 50 ) print ( Health : get ()) -- 50 By default, Vinum accepts changes that set the same value - this is because Vinum doesn't want to restrict you in any way with how you want to manage your projects to some extent, although you can use Vinum.RefuseIfSimilar Processor instead of the function you already passed to implement this.","title":"Holding State"},{"location":"Tutorials/fundamental/hold/#why-the-problem","text":"Hold object doesn't seem to do much rather than simulating a normal variable, so why not use a variable directly? The problem here is that luau variables don't change when any of their dependencies (pieces of data/code we depend on) change. Take this for example: local Health = 100 local midHealth = Health / 2 print ( midHealth ) -- 50 Health = 50 print ( midHealth ) -- 50? In this example, midHealth was actually correct, however, when Health changed to 50, midHealth remained 50, rather than changing to 25. So, to cut a long story short, we don't really have a way to sync variables, and in order to solve that, we need objects that exactly do that for us.","title":"Why: The Problem"},{"location":"Tutorials/fundamental/hold/#why-the-fix","text":"The fix is to have simple objects that at least store a list of dependents (places that depend on us) , so we know who to notify when there is a change. Vinum implements this in the form of \"graph objects\", they are little objects that store a list of dependencies and dependents. They are the objects that are behind all Vinum magic, and in fact Hold is just an abstract object that lets you communicate with them. Hold on the other hand, is designed to act as \"safe-variable\" state object, it has an additional method that is set() that lets you change what value it is Hold ing - additionally, it uses the processor you gave it to determine whether to change its value and notify its dependents, or not.","title":"Why: The Fix"},{"location":"Tutorials/fundamental/observe/","text":"Observing State We often want to listen to changes on our state, which we can use Observe for that. Observe is an object that allows you to run code in response to a change in another state object. Before creating an Observe object, we first need to import it: local Observe = Vinum . Observe Now, to create an Observe object, we first need to feed its constructor an inputState and a processor. Keep in mind that Observe s' processor provides only one parameter, that is newValue . local health = Hold ( 100 , Vinum . RefuseIfSimilar ) local healthObserver = Observe ( health , function ( newValue ) return true end ) Now to connect a handler, we use healthObserve:onChange() . healthObserver : onChange ( function ( newValue ) print ( string.format ( \"Health changed to %s\" , newValue )) end ) Now, when we change health to 50, Health changed to 50 message will be printed. health : set ( 50 ) -- the observer will automatically print `Health changed to 50` Additionally, ...:OnChange() returns a disconnecter, which is just a function that disconnects your handler. Why disconnecting is important While currently Vinum doesn't really care about whether you disconnect connections or not since they can get GC'ed, in the future, Vinum will perform some voodoo magic that will optimize observe s without a handler, and apply some memory safety features. What is a Change? You may think it is a simple question and has a simple answer. However, the answer this question is very flexible, and heavily depends on how you manage updates in Processors. For example, the above example, health 's Processor doesn't allow updates that compute the same result, and the healthObserver allows all update. However, in another scenario, we may use another helper that is: function ( oldValue , newValue ) local oldType = typeof ( oldValue ) local newType = typeof ( newValue ) return oldType == newType and oldValue ~= newValue end This helper is very simple, it implements typechecking and the same mechanism as Vinum.RefuseIfSimilar . Runtime Typechecking Implementing Runtime typechecking is heavily discouraged in Vinum as it decreases performance and adds more bloat. Instead, you are recommended to use your IDE's static typechecker. Additionally, Vinum is typed, so it is able to tell you what value it expects from you. Static typechecking has a few advantages over runtime typechecking, which are but not limited to: Improved performance Almost everything is debuggable from your code editor i.e you don't need to run the whole game to check whether you are passing the wrong type to your state objects. Decreased Code bloat and increased code maintainability. When we use that helper for our health state, we are directly changing when it updates and fires observes, which can be summarized in a few points: if we set health to a value that has a different type than the old one, healthObserver won't fire any connections AND if we set health to the same value, healthObserver won't fire any connections.","title":"Observing State"},{"location":"Tutorials/fundamental/observe/#observing-state","text":"We often want to listen to changes on our state, which we can use Observe for that. Observe is an object that allows you to run code in response to a change in another state object. Before creating an Observe object, we first need to import it: local Observe = Vinum . Observe Now, to create an Observe object, we first need to feed its constructor an inputState and a processor. Keep in mind that Observe s' processor provides only one parameter, that is newValue . local health = Hold ( 100 , Vinum . RefuseIfSimilar ) local healthObserver = Observe ( health , function ( newValue ) return true end ) Now to connect a handler, we use healthObserve:onChange() . healthObserver : onChange ( function ( newValue ) print ( string.format ( \"Health changed to %s\" , newValue )) end ) Now, when we change health to 50, Health changed to 50 message will be printed. health : set ( 50 ) -- the observer will automatically print `Health changed to 50` Additionally, ...:OnChange() returns a disconnecter, which is just a function that disconnects your handler. Why disconnecting is important While currently Vinum doesn't really care about whether you disconnect connections or not since they can get GC'ed, in the future, Vinum will perform some voodoo magic that will optimize observe s without a handler, and apply some memory safety features.","title":"Observing State"},{"location":"Tutorials/fundamental/observe/#what-is-a-change","text":"You may think it is a simple question and has a simple answer. However, the answer this question is very flexible, and heavily depends on how you manage updates in Processors. For example, the above example, health 's Processor doesn't allow updates that compute the same result, and the healthObserver allows all update. However, in another scenario, we may use another helper that is: function ( oldValue , newValue ) local oldType = typeof ( oldValue ) local newType = typeof ( newValue ) return oldType == newType and oldValue ~= newValue end This helper is very simple, it implements typechecking and the same mechanism as Vinum.RefuseIfSimilar . Runtime Typechecking Implementing Runtime typechecking is heavily discouraged in Vinum as it decreases performance and adds more bloat. Instead, you are recommended to use your IDE's static typechecker. Additionally, Vinum is typed, so it is able to tell you what value it expects from you. Static typechecking has a few advantages over runtime typechecking, which are but not limited to: Improved performance Almost everything is debuggable from your code editor i.e you don't need to run the whole game to check whether you are passing the wrong type to your state objects. Decreased Code bloat and increased code maintainability. When we use that helper for our health state, we are directly changing when it updates and fires observes, which can be summarized in a few points: if we set health to a value that has a different type than the old one, healthObserver won't fire any connections AND if we set health to the same value, healthObserver won't fire any connections.","title":"What is a Change?"},{"location":"Tutorials/fundamental/proc/","text":"Processors Processors in Vinum are pure functions that give you control whether you want updates to pass or not. Additionally, they are the best places to include logic such as destruction, middleware, and various mechanisms such as Vinum.RefuseIfSimilar . Stateful State Objects VS Stateless State Objects In Vinum, there are two types of \"state objects\" in - one is Stateful and the other one is Stateless . It can be quite ironic that some \"state objects\" are stateless, however this separation helps us understand what exactly to put in Processors. Stateful Stateful State objects have the ability to have their own state attached to them, examples of these are Hold , Calc , and both Match & Groups (You will be introduced to them at a later point) . These objects always have a method that is used for reading their values, and sometimes a method for value mutation. Due to this ability, Processors that are used with this objects should be used to manage how their respective objects should signal out updates- i.e Processors that dismiss updates if produce the same value. tl;dr Processors for Stateful objects are the best when writing middleware that acts as Should I signal this update . Standard Processors : Vinum.RefuseIfSimilar - This dismisses updates if they produce the same value. Doesn't work for groups. Vinum.RefuseIfSimilarAndCleanup - This dismisses updates they produce the same value, otherwise, it accepts them and attempt to cleanup the old value. Doesn't work for groups. Supported cleanup types: Instances, RBXScriptConnections, function, custom objects that have d/Destroy methods, or arrays that contain supported types Vinum.RefuseIfSimilarInGroup - Same as #1, but instead only works for groups Vinum.RefuseIfSimilarAndCleanupInGroup - same as #2, but instead only works for groups. Vinum.JustOk - This accepts any update. Stateless \"Stateless\" State objects don't have the ability to have their own state attached to them, the only example if them is Observe , which doesn't hold any state to itself. Processors for these objects should be used as a way for filtering updates from their respective objects. This is more of a Should I receive this update . Standard Processors Vinum.JustOk - This accepts any update.","title":"Processors"},{"location":"Tutorials/fundamental/proc/#processors","text":"Processors in Vinum are pure functions that give you control whether you want updates to pass or not. Additionally, they are the best places to include logic such as destruction, middleware, and various mechanisms such as Vinum.RefuseIfSimilar .","title":"Processors"},{"location":"Tutorials/fundamental/proc/#stateful-state-objects-vs-stateless-state-objects","text":"In Vinum, there are two types of \"state objects\" in - one is Stateful and the other one is Stateless . It can be quite ironic that some \"state objects\" are stateless, however this separation helps us understand what exactly to put in Processors.","title":"Stateful State Objects VS Stateless State Objects"},{"location":"Tutorials/fundamental/proc/#stateful","text":"Stateful State objects have the ability to have their own state attached to them, examples of these are Hold , Calc , and both Match & Groups (You will be introduced to them at a later point) . These objects always have a method that is used for reading their values, and sometimes a method for value mutation. Due to this ability, Processors that are used with this objects should be used to manage how their respective objects should signal out updates- i.e Processors that dismiss updates if produce the same value. tl;dr Processors for Stateful objects are the best when writing middleware that acts as Should I signal this update . Standard Processors : Vinum.RefuseIfSimilar - This dismisses updates if they produce the same value. Doesn't work for groups. Vinum.RefuseIfSimilarAndCleanup - This dismisses updates they produce the same value, otherwise, it accepts them and attempt to cleanup the old value. Doesn't work for groups. Supported cleanup types: Instances, RBXScriptConnections, function, custom objects that have d/Destroy methods, or arrays that contain supported types Vinum.RefuseIfSimilarInGroup - Same as #1, but instead only works for groups Vinum.RefuseIfSimilarAndCleanupInGroup - same as #2, but instead only works for groups. Vinum.JustOk - This accepts any update.","title":"Stateful"},{"location":"Tutorials/fundamental/proc/#stateless","text":"\"Stateless\" State objects don't have the ability to have their own state attached to them, the only example if them is Observe , which doesn't hold any state to itself. Processors for these objects should be used as a way for filtering updates from their respective objects. This is more of a Should I receive this update . Standard Processors Vinum.JustOk - This accepts any update.","title":"Stateless"}]}