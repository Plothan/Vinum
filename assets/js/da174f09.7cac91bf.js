"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4305],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>h});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),c=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(o.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(a),h=r,m=d["".concat(o,".").concat(h)]||d[h]||p[h]||l;return a?n.createElement(m,i(i({ref:t},u),{},{components:a})):n.createElement(m,i({ref:t},u))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=d;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<l;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},12722:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>c});var n=a(87462),r=(a(67294),a(3905));const l={sidebar_position:3},i="Calculating State",s={unversionedId:"Basics/Calculating State",id:"Basics/Calculating State",title:"Calculating State",description:"In Vinum, there is a way to implement derived values at scale, which is Calcs. These are equiped with injector functions that allow you to explicitly define the dependencies that will be used.",source:"@site/docs/Basics/Calculating State.md",sourceDirName:"Basics",slug:"/Basics/Calculating State",permalink:"/Vinum/docs/Basics/Calculating State",draft:!1,editUrl:"https://github.com/Plothan/Vinum/edit/master/docs/Basics/Calculating State.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"defaultSidebar",previous:{title:"Observing State",permalink:"/Vinum/docs/Basics/Observing State"},next:{title:"Processors",permalink:"/Vinum/docs/Basics/Processors"}},o={},c=[{value:"Usage",id:"usage",level:2},{value:"Why Calc",id:"why-calc",level:2},{value:"useState and useKeyState: Injectors",id:"usestate-and-usekeystate-injectors",level:2}],u={toc:c};function p(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"calculating-state"},"Calculating State"),(0,r.kt)("p",null,"In Vinum, there is a way to implement derived values at scale, which is ",(0,r.kt)("inlineCode",{parentName:"p"},"Calc"),"s. These are equiped with ",(0,r.kt)("em",{parentName:"p"},"injector")," functions that allow you to explicitly define the dependencies that will be used."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local value = Hold(100, Vinum.AlwaysTrue)\nlocal valueCalced = Calc(function(useState)\n    return useState(value) * 2\nend, function()\n    return true\nend)\n\nvalue:set(50)\nprint(valueCalced:get()) -- 100 is printed\n")),(0,r.kt)("h2",{id:"usage"},"Usage"),(0,r.kt)("p",null,"To use Calc, first import its constructor:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local Calc = Vinum.Calc\n")),(0,r.kt)("p",null,"Now to create a Calc, pass a calculator function, and a processor function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local value = Hold(100, Vinum.AlwaysTrue) -- A processor function that always returns true\nlocal calced = Calc(function(useState, useKeyState)\n    return useState(value) * 2\nend, function(oldValue, newValue)\n    return true\nend)\n")),(0,r.kt)("p",null,"And now to read from that calc, we use its ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"print(calced:get()) -- 200\n")),(0,r.kt)("p",null,"And now, all updates will return be applied, as our ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," object allows all updates, and our ",(0,r.kt)("inlineCode",{parentName:"p"},"calced")," does exactly the same. For more information, read ",(0,r.kt)("inlineCode",{parentName:"p"},"What is a Change")," in ",(0,r.kt)("a",{parentName:"p",href:"/Vinum/docs/Basics/Observing%20State#what-is-a-change"},"Observing State"),"."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"why-calc"},"Why Calc"),(0,r.kt)("p",null,"Calcs are a little more specific than regular observes and holds. They are designed for a single use case, and it is to make deriving from state object possible without efficiency loses or scalability issues."),(0,r.kt)("p",null,"Dervied state is quite common in many of stateful systems, whether they are UI-related, or generally player state. For example, you may want to show our player's health in a UI- and since technically, we can't put the raw health, ",(0,r.kt)("em",{parentName:"p"},"we have to derive a new state that processes the raw health to a Udim2"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Of course")),", this is quite possible with Observes and Holds, however your codebase ",(0,r.kt)("strong",{parentName:"p"},"will")," get messy eventually:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local rawHealth = Hold(100, function()\n    return true\nend)\nlocal healthUdim2 = Hold(UDim2.new(), function()\n    return true\nend)\n\nlocal healthObserver = Observe(rawHealth, function()\n    return true\nend)\n\nhealthObserver:onBind(function(newValue)\n    local hUDim = UDim2.new(rawHealth:get()/ 10, 0, 1, 0)\n\n    healthUdim2:set(hUDim)\nend)\n")),(0,r.kt)("p",null,"However, there are some issues with this current approach, most notably:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"This isnt easy to reason about at first glance- There are a lot of holds and observes that make the overall implementation a bit messy."),(0,r.kt)("li",{parentName:"ul"},"We are manually managing dependency, which means desync bugs can slip in!"),(0,r.kt)("li",{parentName:"ul"},"We created ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"two"))," objects just to derive from a ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"single"))," state object- Can you imagine what we have to do when we have more dependencies?"),(0,r.kt)("li",{parentName:"ul"},"Anybody can change ",(0,r.kt)("inlineCode",{parentName:"li"},"healthUdim2")," at any time- This can be solved using a certain object, however, it will only make it more harder to maintain. Plus, you will eventually invent Calcs accidentally.")),(0,r.kt)("p",null,"These issues are largely fixed in an calc-based implementation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local rawHealth = Hold(100, function() \n    return true\nend)\n\nlocal healthUDim2 = Calc(function(useState)\n    return UDim2.new( useState(rawHealth) / 10, 0, 1, 0)\nend, function()\n    return true\nend)\n")),(0,r.kt)("p",null,"We solved the previously mentioned issues because of:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The intent is very clear, which is to create a UDim2 that represents the current health"),(0,r.kt)("li",{parentName:"ul"},"State management is ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"explicit")),", but not ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"manual")),"- which means, you explicitly tell the Calc what state objects you are deriving from, however, you aren't doing any dependency management work really."),(0,r.kt)("li",{parentName:"ul"},"We just created a singular object when we previously needed two- and the fun part is that this number isn't linear, which means we still need one object for whatever number of dependencies, while with the previous approach, we need to create a lot of observers ",(0,r.kt)("em",{parentName:"li"},"(which will eventually lead to code duplicates)"),"."),(0,r.kt)("li",{parentName:"ul"},"Our object isn't writable at all, which means it is safe to say that any behavior that depends on this state is predictable.")),(0,r.kt)("h2",{id:"usestate-and-usekeystate-injectors"},"useState and useKeyState: Injectors"),(0,r.kt)("p",null,"You might have noticed these functions and their use in ",(0,r.kt)("inlineCode",{parentName:"p"},"Calc"),", and you are wondering what are they, and why they exist. These functions are called ",(0,r.kt)("em",{parentName:"p"},"injectors"),", as they are functions that get injected to the callback, and you also use them to ",(0,r.kt)("em",{parentName:"p"},"inject")," dependencies into a Calc object."),(0,r.kt)("p",null,"Their usage is simply enough to provide a way for you to explicitly define the dependencies, the implicit approach where we automatically detect define our dependencies. This is of course to avoid the headache that comes from automatic detection, most notably:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"When it is implicit, it's very easy to define an object as a dependency to an unrelated object."),(0,r.kt)("li",{parentName:"ul"},"The automatic detector is technically thinking for you, which can be considered a magic system that Just Works.")),(0,r.kt)("p",null,"Injectors greatly solve this by simply introducing the idea of explicitness and strictness. However, since all injectors share the same goal, why there are two injectors?"),(0,r.kt)("p",null,"The answer is that the first one, ",(0,r.kt)("inlineCode",{parentName:"p"},"useState"),", is an injector that accepts the self-contained Vinum objects, such as Calc and Hold , while ",(0,r.kt)("inlineCode",{parentName:"p"},"useKeyState")," is a special injector that is used alongside ",(0,r.kt)("em",{parentName:"p"},"Groups")," which are objects that act as centralized state. Since ",(0,r.kt)("inlineCode",{parentName:"p"},"useKeyState")," is largely tied to them, it is unneeded to explain it ",(0,r.kt)("em",{parentName:"p"},"right now"),"."),(0,r.kt)("p",null,"In the next section, you will be properly introduced to the idea of ",(0,r.kt)("em",{parentName:"p"},"Processors"),", what are they, and what are their properties."))}p.isMDXComponent=!0}}]);