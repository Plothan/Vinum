"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8350],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),m=r,h=p["".concat(s,".").concat(m)]||p[m]||d[m]||o;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},44927:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={sidebar_position:3},i="Manual Memory Management",l={unversionedId:"Advanced/Manual Memory Management",id:"Advanced/Manual Memory Management",title:"Manual Memory Management",description:"Memory management is something needed in general software programming, and it is no different when coding with Vinum.",source:"@site/docs/Advanced/Manual Memory Management.md",sourceDirName:"Advanced",slug:"/Advanced/Manual Memory Management",permalink:"/Vinum/docs/Advanced/Manual Memory Management",draft:!1,editUrl:"https://github.com/Plothan/Vinum/edit/master/docs/Advanced/Manual Memory Management.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"defaultSidebar",previous:{title:"Grouping State",permalink:"/Vinum/docs/Advanced/Grouping State"}},s={},c=[{value:"oldValue Cleanup",id:"oldvalue-cleanup",level:2},{value:"Manual Object Destruction",id:"manual-object-destruction",level:2},{value:"When to Destroy: List",id:"when-to-destroy-list",level:3},{value:"Process-created Objects",id:"process-created-objects",level:4},{value:"Instance Bindings",id:"instance-bindings",level:4}],u={toc:c};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"manual-memory-management"},"Manual Memory Management"),(0,r.kt)("p",null,"Memory management is something needed in general software programming, and it is no different when coding with Vinum."),(0,r.kt)("h2",{id:"oldvalue-cleanup"},"oldValue Cleanup"),(0,r.kt)("p",null,'Since the release of Vinum v0.1, there was this concept of "old value cleanup", which to essentially clean/destroy the old value of a state object. As you might have guessed, this kind of behavior is done in ',(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"stateful"))," processors."),(0,r.kt)("p",null,"This type of memory management has already been introduced to you in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Baiscs")," chapter, so this section will focus on the need of such concept rather than how to use it."),(0,r.kt)("p",null,"Imagine a Hold object that holds an instance value:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local currentInstance = Hold(Instance.new("Part"), AlwaysTrue)\n')),(0,r.kt)("p",null,"This is fine, however, what happens when we ",(0,r.kt)("inlineCode",{parentName:"p"},"set")," our currentInstance with yet another instance?"),(0,r.kt)("p",null,"Well, assuming that we have used any event that ",(0,r.kt)("inlineCode",{parentName:"p"},"currentInstance")," provided, garbage collection won't work, therefore, our old instance will not get destroyed and ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"can cause memory leaks")),"."),(0,r.kt)("p",null,"This can be fixed by using an another stateful processors that performs the necessary cleanup instructions. For example, we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"RefuseIfSimilarAndCleanup"),", which will cleanup the old value ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"if"))," the new value is a different one ",(0,r.kt)("em",{parentName:"p"},"(imagine setting a holder to its own value, which will cause unintended behavior)"),"."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"manual-object-destruction"},"Manual Object Destruction"),(0,r.kt)("p",null,"Since Vinum v0.2, state objects no longer get garbage collected if their root dependencies don't get garbage collected ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"even"))," if they are out of scope."),(0,r.kt)("p",null,"This is because automatic object destruction has caused a major issues with other Vinum's objects, even when they are ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"not"))," out of scope."),(0,r.kt)("p",null,"This has lead to the idea of manual object destruction, as after all, if a feature gets removed for no replacement, then the it is a flawed removal."),(0,r.kt)("p",null,"In order to use manually destruct objects, you must use the standard ",(0,r.kt)("inlineCode",{parentName:"p"},"Vinum.Destroy")," method ",(0,r.kt)("em",{parentName:"p"},"(not to be confused with roblox's instance:Destroy() method)"),", which does the following (order matters!):"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Disconnect relations with all dependencies of the destructed object"),(0,r.kt)("li",{parentName:"ol"},"Call ",(0,r.kt)("inlineCode",{parentName:"li"},"Destory")," on all dependents"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"table.clear")," the state's object table, and then set its metatable to another that will error once indexed.")),(0,r.kt)("h3",{id:"when-to-destroy-list"},"When to Destroy: List"),(0,r.kt)("h4",{id:"process-created-objects"},"Process-created Objects"),(0,r.kt)("p",null,"Sometimes, we create objects in a specific process, and depending on their duty, they may/may not need to be destructed."),(0,r.kt)("p",null,"Consider this Vusion example ",(0,r.kt)("em",{parentName:"p"},"(Vusion is a binding between Vinum and Fusion)"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function comp(props)\n    return Fusion.New "Part" {\n        [Vusion.Key] = {\n            Transparency = Calc(function(useState)\n                -- some computations here\n            end, Vinum.AlwaysTrue)\n        }\n    }\nend\n')),(0,r.kt)("p",null,"In this example, we create a new Calc object every time ",(0,r.kt)("inlineCode",{parentName:"p"},"comp")," is created. This however is ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"dangerious")),", since whenever we call ",(0,r.kt)("inlineCode",{parentName:"p"},"comp"),", we create copies of our calc object, which means memory leaks, and wasted computational power will occur."),(0,r.kt)("p",null,"To solve this, we could call Destroy on all Calc objects that we create every time ",(0,r.kt)("inlineCode",{parentName:"p"},"comp")," is called."),(0,r.kt)("h4",{id:"instance-bindings"},"Instance Bindings"),(0,r.kt)("p",null,"Instance bindings are very common in Vinum codebases, as they are the layer at which you derive state from your main data model ",(0,r.kt)("em",{parentName:"p"},"(that is the one managed by Vinum)"),", and reflect it on the Roblox's datamodel."),(0,r.kt)("p",null,"Internally, all instance bindings use an ",(0,r.kt)("inlineCode",{parentName:"p"},"observe"),", which we would eventually want to cleanup once the binded instance is destroyed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function bindWithInstance(state, propName, instance)\n    local observer = Observe(state, AlwaysTrue)\n\n    observer:onBind(function(newValue)\n        instance[propName] = newValue\n    end)\n\n    instance.Destroying:Connect(function()\n        Vinum.Destroy(observer)\n    end)\nend\n")))}d.isMDXComponent=!0}}]);