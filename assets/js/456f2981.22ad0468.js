"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6225],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>m});var s=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function n(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,s)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?n(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,s,a=function(e,t){if(null==e)return{};var r,s,a={},n=Object.keys(e);for(s=0;s<n.length;s++)r=n[s],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(s=0;s<n.length;s++)r=n[s],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var i=s.createContext({}),u=function(e){var t=s.useContext(i),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},c=function(e){var t=u(e.components);return s.createElement(i.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},d=s.forwardRef((function(e,t){var r=e.components,a=e.mdxType,n=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(r),m=a,f=d["".concat(i,".").concat(m)]||d[m]||p[m]||n;return r?s.createElement(f,o(o({ref:t},c),{},{components:r})):s.createElement(f,o({ref:t},c))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var n=r.length,o=new Array(n);o[0]=d;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var u=2;u<n;u++)o[u]=r[u];return s.createElement.apply(null,o)}return s.createElement.apply(null,r)}d.displayName="MDXCreateElement"},3919:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>i,contentTitle:()=>o,default:()=>p,frontMatter:()=>n,metadata:()=>l,toc:()=>u});var s=r(87462),a=(r(67294),r(3905));const n={sidebar_position:4},o="Processors",l={unversionedId:"Basics/Processors",id:"Basics/Processors",title:"Processors",description:"Processors are the most essential part of Vinum, they give you control to change the control flow of updates to some extent.",source:"@site/docs/Basics/Processors.md",sourceDirName:"Basics",slug:"/Basics/Processors",permalink:"/Vinum/docs/Basics/Processors",draft:!1,editUrl:"https://github.com/Plothan/Vinum/edit/master/docs/Basics/Processors.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"defaultSidebar",previous:{title:"Calculating State",permalink:"/Vinum/docs/Basics/Calculating State"},next:{title:"Matching State",permalink:"/Vinum/docs/Intermediate/Matching State"}},i={},u=[{value:"Stateful Processors",id:"stateful-processors",level:2},{value:"Standard Stateful Processors",id:"standard-stateful-processors",level:3},{value:"Stateless Processors",id:"stateless-processors",level:2},{value:"Standard Stateless Processors",id:"standard-stateless-processors",level:3}],c={toc:u};function p(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,s.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"processors"},"Processors"),(0,a.kt)("p",null,"Processors are the most essential part of Vinum, they give you control to change the control flow of updates to some ",(0,a.kt)("em",{parentName:"p"},"extent"),"."),(0,a.kt)("p",null,"However, Processors themselves have different types, and each type has a specific usecase tied to itself. The factor that the classification is based off is simply if they're aware of the respective state object's old value or not."),(0,a.kt)("p",null,"That being said, Processors have only two types; ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"stateful"))," processors and ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"stateless"))," processors, and you have actually used the both!"),(0,a.kt)("h2",{id:"stateful-processors"},"Stateful Processors"),(0,a.kt)("p",null,"Stateful Processors are really simple, and are responsible for their object's update flow, and general cleanup if needed. Consider this an implementation of a stateful processor for a Hold object:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"local function HoldProcessor<T>(oldValue: T, newValue: T): boolean\n    return oldValue ~= newValue\nend\n")),(0,a.kt)("p",null,"This has a really simple behavior, which is:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If the old value is equal to the new value, dismiss the update"),(0,a.kt)("li",{parentName:"ul"},"otherwise, pass the update")),(0,a.kt)("p",null,"Stateful Processors, just like previously mentioned, are the best places to manage our object's update flow, and additionally, we can perform general cleanup as well there."),(0,a.kt)("h3",{id:"standard-stateful-processors"},"Standard Stateful Processors"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Vinum.AlwaysTrue")," - Always returns true"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Vinum.RefuseIfSimilar")," - Returns false if the oldValue is the same as newValue"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Vinum.RefuseIfSimilarAndCleanup")," - Same as RefuseIfSimilar, but performs cleanup when an update is passed"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Vinum.RefuseIfSimilarInGroup")," - same as RefuseIfSimilar, but acts as a port for Groups."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Vinum.RefuseIfSimilarAndCleanupInGroup")," - Same as RefuseIfSimilarAndCleanup, but acts as a port for Groups")),(0,a.kt)("p",null,"Types that cleanups accept:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Instance: Destroy"),(0,a.kt)("li",{parentName:"ul"},"RBXScriptConnnection: Disconnect"),(0,a.kt)("li",{parentName:"ul"},"Function: Call"),(0,a.kt)("li",{parentName:"ul"},"Table that has destroy/Destroy: Distroy"),(0,a.kt)("li",{parentName:"ul"},"Array of tasks: call the cleaner on each subtask")),(0,a.kt)("h2",{id:"stateless-processors"},"Stateless Processors"),(0,a.kt)("p",null,"Stateless Processors, unlike their stateful counterparts, act as places for ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"filtering")),". Though it is important to keep in mind that ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"cleanup should NOT be perfomed in stateless processors")),"- this is generally because stateless processors are used in objects that ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"don't"))," have any state, therefore, they use the object's dependency's value, so any mutation of the said value is disallowed."),(0,a.kt)("h3",{id:"standard-stateless-processors"},"Standard Stateless Processors"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Vinum.AlwaysTrue")," - Always returns true")))}p.isMDXComponent=!0}}]);